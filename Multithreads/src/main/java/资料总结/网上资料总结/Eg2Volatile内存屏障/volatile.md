###锁和volatile
1.原子性：原子性即一次只允许一个线程持有某个特定的锁，一次就只有一个线程能够使用共享数据。  
2.可见性: 可见性是必须确保释放锁之前对共享数据做出的更改对于随后获得该锁的另一个线程是可见的 。

当一个变量定义为 volatile 之后，将具备：  
1.保证此变量对所有的线程的可见性，当一个线程修改了这个变量的值，volatile 保证了新值能立即同步到主内存，其它线程每次使用前立即从主内存刷新。但普通变量做不到这点，普通变量的值在线程间传递均需要通过主内存来完成。  
2.禁止指令重排序优化。有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个内存屏障（指令重排序时不能把后面的指令重排序到内存屏障之前的位置）

###指令重排序
有序性：即程序执行的顺序按照代码的先后顺序执行。  
1.***JVM***在执行代码的时候可能会发生指令重排序。  
2.一般来说，***处理器***为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。  

处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，靠的是数据依赖性：    
  
编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。

###内存屏障
内存屏障分为两种：Load Barrier 和 Store Barrier即读屏障和写屏障。  
内存屏障有两个作用：  
1.阻止屏障两侧的指令重排序；  
2.强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效。  

对于Load Barrier来说，在指令前插入Load Barrier，可以让高速缓存中的数据失效，强制从新从主内存加载数据；  
对于Store Barrier来说，在指令后插入Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见。  

java的内存屏障通常所谓的四种即LoadLoad,StoreStore,LoadStore,StoreLoad实际上也是上述两种的组合，完成一系列的屏障和数据同步功能。  

LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。  
StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。  
LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。  
StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能  
参考：https://www.jianshu.com/p/ef8de88b1343